{"name":"Saf","tagline":"SAF(Simple Android Framework)是一个简单的android框架，它为开发Android app提供了基础性组件。","body":"SAF\r\n===\r\nSAF(Simple Android Framework)是一个简单的android框架，它为开发Android app提供了基础性组件。<br>\r\nSAF已经在多个项目中使用，包括今夜酒店特价app、锦江之星app、京东内部的一个app等等。这个项目第一次提交到google code是2012年的3月26号，我已经断断续续做了2年多了。2014年9月开始[frankswu](https://github.com/frankswu)加入跟我一起开发SAF<br>\r\n目前google code上的工程暂停维护，迁移到github上。它刚刚到1.1.x版本，肯定会存在各种各样的问题。遇到任何问题欢迎跟我的qq联系，qq：63067756\r\n\r\n\r\n主要功能\r\n-----------------------------------\r\n* [SAFApp](https://github.com/fengzhizi715/SAF#safapp)\r\n* [Event Bus](https://github.com/fengzhizi715/SAF#event-bus)\r\n* [Rest Client](https://github.com/fengzhizi715/SAF#rest-client)\r\n* [Image Cache](https://github.com/fengzhizi715/SAF#image-cache)\r\n* [Dependency Injection](https://github.com/fengzhizi715/SAF#dependency-injection)\r\n* [Sqlite ORM](https://github.com/fengzhizi715/SAF#sqlite-orm)\r\n* [Router](https://github.com/fengzhizi715/SAF#router)\r\n* [Utils](https://github.com/fengzhizi715/SAF#utils)\r\n\r\nSAFApp\r\n===\r\nSAFApp其实不能算是一个完整的模块，SAFApp继承了Application。增加了一个可作为缓存存放app全局变量的session，一个ImageLoader，一个记录Activity的List。\r\n\r\nEvent Bus\r\n===\r\n事件总线框架，类似于google guava、square otto的event bus。它是一种消息发布-订阅模式,它的工作机制类似于观察者模式，通过通知者去注册观察者，最后由通知者向观察者发布消息。\r\n\r\nEvent Bus解耦了asyncTask、handler、thread、broadcast等组件。使用Event bus可以轻松地跨多个Fragment进行通讯。\r\n\r\n它用法很简单，在Activity或者Fragment中使用，其中event是一个简单的POJO<br />\r\n<pre><code>\r\n// 退出系统的事件\r\neventBus.post(new LogoutEvent());\r\n</pre></code>\r\n\r\n回调事件，同样在Activity或者Fragment中定义好。回调方法名可以随便定义，参数须要和event一一对应。并且在方法名前加上注解Subscribe\r\n\r\n         /**\r\n          * 退出整个app\r\n          * @param event\r\n          */\r\n          @Subscribe\r\n          public void onLogoutEvent(LogoutEvent event) {\r\n          }\r\n          \r\n          \r\n@Subscribe可以使用枚举<br />\r\n\r\n         /**\r\n          * 使用ThreadMode.BackgroundThread枚举，表示在后台线程运行，不在主线程中运行。\r\n          * @param event\r\n          */\r\n          @Subscribe(ThreadMode.BackgroundThread)\r\n          public void onBackendFresh(BackendFreshEvent event) {\r\n          \r\n          }\r\n使用枚举BackgroundThread时，如果在回调方法中需要更新ui，则必须要配合handler使用。 在不使用枚举的情况下，@Subscribe会默认使用PostThread，表示回调方法会在主线程中运行。 如果在一个Activity中存在多个Fragment，并且在Activity或者在Fragment中存在订阅同一event的回调方法。如果发出event的请求时，这些回调方法都会起作用。\r\n\r\n\r\nRest Client\r\n===\r\nRest Client模块提供了http的get、post、put、delete方法。这个模块还不是很完善，只是适应自身项目需要，未来会不断增加新的功能。 这个模块没有基于apache httpclient，完全基于jdk中的HttpURLConnection。\r\n\r\n同步调用get方法：\r\n<pre><code>\r\n          RestClient client = RestClient.get(url);<p>\r\n          String body = client.body();\r\n</pre></code>\r\n\r\n异步调用get方法：\r\n\r\n          RestClient.get(url,new HttpResponseHandler(){\r\n              \r\n              public void onSuccess(String content) {\r\n                // content为http请求成功后返回的response\r\n              }\r\n          });\r\n\r\n\r\n同步调用post方法：post body内容为json\r\n\r\n          RestClient client = RestClient.post(url);\r\n          client.acceptJson().contentType(\"application/json\", null);\r\n          client.send(jsonString); // jsonString是已经由json对象转换成string类型\r\n          String body = client.body();\r\n\r\n\r\n异步调用post方法：post body内容为json\r\n\r\n          RestClient.post(url,json,new HttpResponseHandler(){ // json对应的是fastjson的JSONObject对象\r\n        \r\n                public void onSuccess(String content) {\r\n                }\r\n        \r\n           });\r\n\r\n\r\n异步调用post方法：以form形式传递数据\r\n\r\n          RestClient.post(urlString, map, new HttpResponseHandler(){\r\n\r\n                @Override\r\n                public void onSuccess(String content) {\r\n\r\n                }\r\n                                        \r\n          });\r\n\r\n\r\nImage Cache\r\n===\r\n图片缓存模块包括2级缓存，内存中的cache和sd卡上存放在文件中的cache。\r\n\r\n图片缓存模块通过ImageLoader进行图片加载。 如果app中使用了SAFApp，则无须创建新的ImageLoader就可以使用。     \r\n<pre><code>\r\n          // 第一个参数是图片的url，第二个参数是ImageView对象，第三个参数是默认图片\r\n          imageLoader.displayImage(url, imageView ,R.drawable.defalut_icon);\r\n</pre></code>\r\n\r\n\r\nDependency Injection\r\n===\r\nDependency Injection是依赖注入的意思，简称DI。\r\n\r\nSAF中的DI包括以下几个方面：\r\n* Inject View ：简化组件的查找注册，目前支持约定大于配置，如果代码中的组件名称跟layout中要注入的组件id相同，则无需写(id=R.id.xxxx)\r\n* Inject Views：支持多个相同类型组件的注入\r\n* Inject Service ：简化系统服务的注册，目前只支持android的系统服务\r\n* Inject Extra ：简化2个Activity之间Extra传递\r\n* InflateLayout ：简化布局填充时，组件的查找注册\r\n* OnClick：简化各种组件的Click事件写法\r\n* OnItemClick：简化ListView的ItemView事件写法\r\n\r\nInject View\r\n---\r\nInject View可以简化组件的查找注册，包括android自带的组件和自定义组件。在使用Inject View之前，我们会这样写代码\r\n\r\n          public class MainActivity extends Activity {\r\n                \r\n                private ImageView imageView;\r\n                \r\n                @Override\r\n                protected void onCreate(Bundle savedInstanceState) {\r\n                  super.onCreate(savedInstanceState);\r\n                  \r\n                  setContentView(R.layout.activity_main);\r\n                  imageView = (ImageView) findViewById(R.id.imageview);\r\n                }\r\n           }\r\n\r\n\r\n在使用Inject View之后，会这样写代码\r\n\r\n          public class MainActivity extends Activity {\r\n                    \r\n                @InjectView(id= R.id.imageview)\r\n                private ImageView imageView;\r\n                    \r\n                @Override\r\n                protected void onCreate(Bundle savedInstanceState) {\r\n                   super.onCreate(savedInstanceState);\r\n                      \r\n                   setContentView(R.layout.activity_main);\r\n                   Injector.injectInto(this);\r\n                }\r\n          }\r\n\r\n约定大于配置的写法，无需写(id= R.id.imageview)\r\n\r\n          public class MainActivity extends Activity {\r\n                    \r\n                @InjectView\r\n                private ImageView imageview;\r\n                    \r\n                @Override\r\n                protected void onCreate(Bundle savedInstanceState) {\r\n                   super.onCreate(savedInstanceState);\r\n                      \r\n                   setContentView(R.layout.activity_main);\r\n                   Injector.injectInto(this);\r\n                }\r\n          }\r\n\r\n目前，@InjectView可用于Activity、Dialog、Fragment中。在Activity和Dialog用法相似，在Fragment中用法有一点区别。\r\n\r\n          public class DemoFragment extends Fragment {\r\n\r\n                   @InjectView(id=R.id.title)\r\n                   private TextView titleView;\r\n\r\n                   @InjectView(id=R.id.imageview)\r\n                   private ImageView imageView;\r\n\r\n                   @Override\r\n                   public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\r\n                          View v = inflater.inflate(R.layout.fragment_demo, container, false);\r\n\r\n                          Injector.injectInto(this,v); // 和Activity使用的区别之处在这里\r\n          \r\n                          initViews();\r\n                          initData();\r\n          \r\n                          return v;\r\n                   }\r\n          \r\n                  ......\r\n           }\r\n\r\nInject Views\r\n---\r\n          public class MainActivity extends Activity {\r\n                    \r\n                @InjectViews(ids={R.id.imageView1,R.id.imageView2})\r\n                private List<ImageView> imageviews;\r\n                    \r\n                @Override\r\n                protected void onCreate(Bundle savedInstanceState) {\r\n                   super.onCreate(savedInstanceState);\r\n                      \r\n                   setContentView(R.layout.activity_main);\r\n                   Injector.injectInto(this);\r\n                }\r\n          }\r\n\r\n\r\nInject Extra\r\n---\r\n\r\n         /**\r\n          * MainActivity传递数据给SecondActivity\r\n          * Intent i = new Intent(MainActivity.this,SecondActivity.class);                                               \r\n          * i.putExtra(\"test\", \"saf\");\r\n          * i.putExtra(\"test_object\", hello);\r\n          * startActivity(i);\r\n          * 在SecondActivity可以使用@InjectExtra注解\r\n          *\r\n          * @author Tony Shen\r\n          *\r\n          */\r\n         public class SecondActivity extends Activity{\r\n\r\n               @InjectExtra(key=\"test\")\r\n               private String testStr;\r\n        \r\n               @InjectExtra(key=\"test_object\")\r\n               private Hello hello;\r\n        \r\n               protected void onCreate(Bundle savedInstanceState) {\r\n                   super.onCreate(savedInstanceState);\r\n                \r\n                   Injector.injectInto(this);\r\n                   Log.i(\"++++++++++++\",\"testStr=\"+testStr);\r\n                   Log.i(\"++++++++++++\",\"hello=\"+SAFUtil.printObject(hello)); // 该方法用于打印对象\r\n              }\r\n          }\r\n\r\nInflateLayout\r\n---\r\n\r\n        /**\r\n         * @author Tony Shen\r\n         *\r\n         */\r\n         @InflateLayout(id=R.layout.my_view)\r\n         public class MyView extends LinearLayout {\r\n\r\n              @InjectView(id = R.id.textview1)\r\n\t          public TextView view1;\r\n    \r\n              @InjectView(id = R.id.textview2)\r\n\t          public TextView view2;\r\n\t\r\n\t         public MyView(Context context) {\r\n\t\t         super(context);\r\n\t         }\r\n        }\r\n\r\n\r\n在Activity、Fragment中的写法:\r\n<pre><code> \t\r\n         MyView myView = Injector.build(mContext, MyView.class);\r\n</pre></code>\r\n\r\n\r\nOnClick\r\n---\r\n@OnClick 可以在Activity、Fragment、Dialog、View中使用，支持多个组件绑定同一个方法。\r\n\r\n     public class AddCommentFragment extends BaseFragment {\r\n    \r\n         @Override\r\n         public View onCreateView(LayoutInflater inflater, ViewGroup container,\r\n                             Bundle savedInstanceState) {\r\n\r\n             View v = inflater.inflate(R.layout.fragment_add_comment, container, false);\r\n\r\n             Injector.injectInto(this, v);\r\n\r\n             initView();\r\n\r\n             return v;\r\n        }\r\n    \r\n\t    @OnClick(id={R.id.left_menu,R.id.btn_comment_cancel})\r\n\t    void clickLeftMenu() {\r\n\t\t    popBackStack();\r\n\t    }\r\n\t\r\n\t    @OnClick(id=R.id.btn_comment_send)\r\n\t    void clickCommentSend() {\r\n            if (StringHelper.isBlank(commentEdit.getText().toString())) {\r\n               ToastUtil.showShort(mContext, R.string.the_comment_need_more_character);\r\n            } else {\r\n               AsyncTaskExecutor.executeAsyncTask(new AddCommentTask(showDialog(mContext)));\r\n            }\r\n\t    }\r\n\t    \r\n\t    ....\r\n    }\r\n\r\n\r\nSqlite ORM\r\n===\r\n顾名思义就是sqlite的orm框架，采用oop的方式简化对sqlite的操作。 首先需要在AndroidManifest.xml中配上一些参数\r\n\r\n        <!-- 表示在com.example.testsaf.db这个package下的类都是db的domain，一个类对应db里的一张表-->\r\n        <meta-data\r\n            android:name=\"DOMAIN_PACKAGE\"\r\n            android:value=\"com.example.testsaf.db\" />\r\n        \r\n        <!-- 表示db的名称-->\r\n        <meta-data\r\n            android:name=\"DB_NAME\"\r\n            android:value=\"testsaf.db\" />\r\n \r\n         <!-- 表示db的版本号-->\r\n         <meta-data\r\n            android:name=\"DB_VERSION\"\r\n            android:value=\"1\" />\r\n\r\n\r\n使用orm框架需要初始化DBManager，需要在Applicaion中完成。SAF中的SAFApp，没有初始化DBManager，如果需要使用SAFApp可以重写一个Application继承SAFApp，并初始化DBManager。\r\n\r\n          /**\r\n           * @author Tony Shen\r\n           *\r\n           */\r\n           public class TestApp extends Application{\r\n\r\n                @Override\r\n                public void onCreate() {\r\n                   super.onCreate();\r\n                   DBManager.initialize(this);\r\n                }\r\n  \r\n           }\r\n\r\ndb的domain使用是也是基于注解\r\n\r\n          /**\r\n           * \r\n           * 表示sqlite中autocomplete表的属性\r\n           * @author Tony Shen\r\n           * \r\n           */\r\n          @Table(name=\"autocomplete\")\r\n          public class Autocomplete extends DBDomain{\r\n\r\n              @Column(name=\"key_words\",length=20,notNull=true)\r\n              public String KEY_WORDS;\r\n        \r\n              @Column(name=\"key_type\",length=20,notNull=true)\r\n              public String KEY_TYPE;\r\n        \r\n              @Column(name=\"key_reference\",length=80)\r\n              public String KEY_REFERENCE;\r\n          }\r\n\r\n\r\ndb的操作很简单\r\n\r\n          Autocomplete auto = new Autocomplete();\r\n          auto.KEY_TYPE = \"1\";\r\n          auto.KEY_WORDS = \"testtest\";\r\n          auto.save(); // 插入第一条记录\r\n\r\n          Autocomplete auto2 = new Autocomplete();\r\n          auto2.KEY_TYPE = \"0\";\r\n          auto2.KEY_WORDS = \"haha\";\r\n          auto2.save(); // 插入第二条记录\r\n\r\n          Autocomplete auto3 = new Autocomplete().get(1); // 获取Autocomplete的第一条记录\r\n          if (auto3!=null) {\r\n               Log.i(\"+++++++++++++++\",\"auto3.KEY_WORDS=\"+auto3.KEY_WORDS);\r\n          } else {\r\n               Log.i(\"+++++++++++++++\",\"auto3 is null!\");\r\n          }\r\n\r\n\r\n查询结果集\r\n<pre><code>\r\nList list = new Autocomplete().executeQuery(\"select * from autocomplete where KEY_WORDS = 'testtest'\");\r\nLog.i(\"+++++++++++++++\",\"list.size()=\"+list.size());  // 根据sql条件查询\r\n                \r\nList list2 = new Autocomplete().executeQuery(\"select * from autocomplete where KEY_WORDS = ? and Id = ?\",\"testtest\",\"1\");\r\nLog.i(\"+++++++++++++++\",\"list2.size()=\"+list2.size()); // 表示查询select * from autocomplete where KEY_WORDS = 'testtest' and Id = '1'\r\n</pre></code> \r\n\r\n\r\nRouter\r\n===\r\n类似于rails的router功能，Activity之间、Fragment之间可以轻易实现相互跳转，并传递参数。 使用Activity跳转必须在Application中做好router的映射。 我们会做这样的映射，表示从某个Activity跳转到另一个Activity需要传递user、password2个参数\r\n\r\n          Router.getInstance().setContext(getApplicationContext()); // 这一步是必须的，用于初始化Router\r\n          Router.getInstance().map(\"user/:user/password/:password\", SecondActivity.class);\r\n\r\n\r\n有时候，activity跳转还会有动画效果，那么我们可以这么做\r\n\r\n          RouterOptions options = new RouterOptions();\r\n          options.enterAnim = R.anim.slide_right_in;\r\n          options.exitAnim = R.anim.slide_left_out;\r\n          Router.getInstance().map(\"user/:user/password/:password\", SecondActivity.class, options);\r\n\r\n\r\n在Application中定义好映射，activity之间跳转只需在activity中写下如下的代码，即可跳转到相应的Activity，并传递参数\r\n<pre><code>\r\n           Router.getInstance().open(\"user/fengzhizi715/password/715\");\r\n</pre></code>\r\n\r\n如果在跳转前需要先做判断，看看是否满足跳转的条件,doCheck()返回false表示不跳转，true表示进行跳转到下一个activity\r\n\r\n          Router.getInstance().open(\"user/fengzhizi715/password/715\",new RouterChecker(){\r\n\r\n                 public boolean doCheck() {\r\n                     return true;\r\n                 }\r\n          });\r\n\r\n\r\n单独跳转到某个网页，调用系统电话，调用手机上的地图app打开地图等无须在Application中定义跳转映射。\r\n\r\n          Router.getInstance().openURI(\"http://www.g.cn\");\r\n\r\n          Router.getInstance().openURI(\"tel://18662430000\");\r\n\r\n          Router.getInstance().openURI(\"geo:0,0?q=31,121\");\r\n\r\n\r\nFragment之间的跳转也无须在Application中定义跳转映射。直接在某个Fragment写下如下的代码\r\n<pre><code>\r\n         Router.getInstance().openFragment(new FragmentOptions(getFragmentManager(),new Fragment2()), R.id.content_frame);\r\n</pre></code>\r\n\r\n当然在Fragment之间跳转可以传递参数\r\n<pre><code>\r\nRouter.getInstance().openFragment(\"user/fengzhizi715/password/715\",new FragmentOptions(getFragmentManager(),new Fragment2()), R.id.content_frame);\r\n</pre></code>\r\n\r\n\r\nUtils\r\n===\r\n包含了很多常用的工具类，比如日期操作、字符串操作、SAFUtil里包含各种乱七八糟的常用类等等。","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}